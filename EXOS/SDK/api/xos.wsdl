<?xml version="1.0" encoding="UTF-8" ?> 

<!-- Copyright (c) Extreme Networks Inc. 2003, 2004. 
     All rights reserved. -->

<!-- WSDL description of the XOS XML APIs.
     The XOS XML APIs are in beta release. -->

<definitions name="Xos"
             targetNamespace="urn:xapi"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:tns="urn:xapi"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">

  <!-- Types for XOS APIs -->

  <types>
    <xsd:schema targetNamespace="urn:xapi"
                xmlns="http://www.w3.org/2001/XMLSchema">

      <!-- Common types -->

      <xsd:complexType name="Common-StringSequence">
		 <xsd:annotation>
		 	<xsd:documentation>Sequence of strings.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:sequence>
          <xsd:element name="name" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:complexType>

      <!--  Vlan types -->

      <xsd:complexType name="Vlan-VlanEntry">
		 <xsd:annotation>
				 <xsd:documentation>
						 (Deprecated) VLAN configuration.
						 <br/>
						 NOTE: All VLAN-related operations and types defined here are deprecated.
						 Use switch.wsdl and vlan.xsd instead.
				 </xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
          <xsd:element name="name"                  type="xsd:string"/>
          <xsd:element name="vr"                    type="xsd:string"/>
          <xsd:element name="tag"                   type="xsd:integer"/>
          <xsd:element name="ipMtu"                 type="xsd:integer"/>
          <xsd:element name="qosProfile"            type="xsd:string"/>
          <xsd:element name="isLoopbackEnabled"     type="xsd:boolean"/>
          <xsd:element name="isIpForwardingEnabled" type="xsd:boolean"/>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Vlan-VlanEntrySequence">
		 <xsd:annotation>
				 <xsd:documentation>
						 (Deprecated) Sequence of VLAN configuration objects.
						 <br/>
						 NOTE: All VLAN-related operations and types defined here are deprecated.
						 Use switch.wsdl and vlan.xsd instead.
				 </xsd:documentation>
	 	 </xsd:annotation>
        <xsd:sequence>
          <xsd:element name="vlan" type="tns:Vlan-VlanEntry" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:complexType>

      <!--  Fdb types -->

      <xsd:complexType name="Fdb-FdbEntry">
		 <xsd:annotation>
			 <xsd:documentation>An entry in the forwarding database (FDB) table.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
			<xsd:element name="macAddress"  type="xsd:string">
		 		<xsd:annotation>
			 		<xsd:documentation>MAC address.</xsd:documentation>
	 	 		</xsd:annotation>
			</xsd:element>
			<xsd:element name="vlan"        type="xsd:string">
		 		<xsd:annotation>
			 		<xsd:documentation>VLAN name.</xsd:documentation>
	 	 		</xsd:annotation>
			</xsd:element>
			<xsd:element name="port"        type="xsd:string">
		 		<xsd:annotation>
			 		<xsd:documentation>Port number.</xsd:documentation>
	 	 		</xsd:annotation>
			</xsd:element>
			<xsd:element name="age"         type="xsd:long">
		 		<xsd:annotation>
			 		<xsd:documentation>Age of the entry (in seconds).</xsd:documentation>
	 	 		</xsd:annotation>
			</xsd:element>
			<xsd:element name="isStatic"    type="xsd:boolean">
		 		<xsd:annotation>
			 		<xsd:documentation>Indicates whether entry is static.</xsd:documentation>
	 	 		</xsd:annotation>
			</xsd:element>
			<xsd:element name="isPermanent" type="xsd:boolean">
		 		<xsd:annotation>
			 		<xsd:documentation>Indicates whether entry is permanent.</xsd:documentation>
	 	 		</xsd:annotation>
			</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Fdb-FdbEntrySequence">
		 <xsd:annotation>
			 <xsd:documentation>Sequence of FDB entries.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:sequence>
				<xsd:element name="fdb" type="tns:Fdb-FdbEntry" minOccurs="0" maxOccurs="unbounded">
		 			<xsd:annotation>
						 <xsd:documentation>FDB entry.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <!-- Policy types -->

      <xsd:simpleType name="Policy-ClearflowMatchType">
		 <xsd:annotation>
			 <xsd:documentation>Enumeration of CLEAR-Flow match types.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="MATCH_ANY"/>
          <xsd:enumeration value="MATCH_ALL"/>
        </xsd:restriction>
      </xsd:simpleType>

      <xsd:simpleType name="Policy-ClearflowConditionOperator">
		 <xsd:annotation>
			 <xsd:documentation>Enumeration of CLEAR-Flow condition operators.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="LESS_THAN"/>
          <xsd:enumeration value="LESS_EQUAL"/>
          <xsd:enumeration value="GREATER_THAN"/>
          <xsd:enumeration value="GREATER_EQUAL"/>
        </xsd:restriction>
      </xsd:simpleType>

      <xsd:simpleType name="Policy-ClearflowConditionType">
		 <xsd:annotation>
			 <xsd:documentation>Enumeration of CLEAR-Flow condition types.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="COUNT"/>
          <xsd:enumeration value="DELTA"/>
          <xsd:enumeration value="RATIO"/>
          <xsd:enumeration value="DELTA_RATIO"/>
          <xsd:enumeration value="RULE_COUNT"/>
        </xsd:restriction>
      </xsd:simpleType>

      <xsd:simpleType name="Policy-ClearflowActionSyslogLevel">
		 <xsd:annotation>
			 <xsd:documentation>Enumeration of syslog levels for CLEAR-Flow actions.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="DEBUG"/>
          <xsd:enumeration value="INFO"/>
          <xsd:enumeration value="NOTIFY"/>
          <xsd:enumeration value="WARN"/>
          <xsd:enumeration value="ERROR"/>
          <xsd:enumeration value="CRITICAL"/>
        </xsd:restriction>
      </xsd:simpleType>

      <xsd:complexType name="Policy-Policy">
		 <xsd:annotation>
			 <xsd:documentation>Defines a policy.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="name"           type="xsd:string">
		 			<xsd:annotation>
						 <xsd:documentation>Policy name.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="aclRules"       type="tns:Policy-AclRuleSequence">
		 			<xsd:annotation>
						 <xsd:documentation>ACL rules in the policy.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="clearflowRules" type="tns:Policy-ClearflowRuleSequence">
		 			<xsd:annotation>
						 <xsd:documentation>CLEAR-Flow rules in the policy.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-AclRule">
		 <xsd:annotation>
			 <xsd:documentation>Defines an ACL rule.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="name"     type="xsd:string">
		 			<xsd:annotation>
						 <xsd:documentation>ACL rule name.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="applicationName" type="xsd:string" minOccurs="0">
		 			<xsd:annotation>
						 <xsd:documentation>Application name.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="isPersistent" type="xsd:boolean" minOccurs="0">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether ACL is persisted across switch restarts.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="match"    type="tns:Policy-AclCondition">
		 			<xsd:annotation>
						 <xsd:documentation>ACL matching conditions.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="response" type="tns:Policy-AclAction">
		 			<xsd:annotation>
						 <xsd:documentation>ACL actions in response to match conditions.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowRule">
		 <xsd:annotation>
			 <xsd:documentation>Defines a CLEAR-Flow rule.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="name"             type="xsd:string">
		 			<xsd:annotation>
						 <xsd:documentation>CLEAR-Flow rule name.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="match"            type="tns:Policy-ClearflowMatch">
		 			<xsd:annotation>
						 <xsd:documentation>CLEAR-Flow matching conditions.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="positiveResponse" type="tns:Policy-ClearflowAction">
		 			<xsd:annotation>
						 <xsd:documentation>CLEAR-Flow action in response to meeting match conditions ("if" part).</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="negativeResponse" type="tns:Policy-ClearflowAction">
		 			<xsd:annotation>
						 <xsd:documentation>CLEAR-Flow action in response to not meeting match conditions ("else" part).</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowMatch">
		 <xsd:annotation>
			 <xsd:documentation>CLEAR-Flow match condition.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:sequence>
				<xsd:element name="period"     type="xsd:integer">
		 			<xsd:annotation>
						 <xsd:documentation>Period or sampling interval (in seconds).</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="comparison" type="tns:Policy-ClearflowCondition" minOccurs="0" maxOccurs="4">
		 			<xsd:annotation>
						 <xsd:documentation>Comparison expressions. There can be upto 4 expressions in a rule.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:sequence>
        <xsd:attribute name="type" type="tns:Policy-ClearflowMatchType"/>
      </xsd:complexType>

      <xsd:complexType name="Policy-AclCondition">
		 <xsd:annotation>
				 <xsd:documentation>
						 ACL match condition.
						 <br/>
						 Please refer to the "ExtremeXOS Reference" and "ExtremeXOS Concepts Guide" 
						 for a detailed description of the ACL feature and the use of various match conditions
						 and actions.
				 </xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="srcIpAddress"       type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Source IP address.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="dstIpAddress"       type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Destination IP address.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="srcPort"            type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Source port.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="dstPort"            type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Destination port.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="srcEthernetAddress" type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Source ethernet or MAC address.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="dstEthernetAddress" type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Destination ethernet or MAC address.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="ethernetType"       type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Ethernet type.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="firstFragments"     type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>No-IP or first-fragment packets.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="fragments"          type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>IP fragmented packets.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="icmpCode"           type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>ICMP code.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="icmpType"           type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>ICMP type.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="igmpMsgType"        type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>IGMP message type.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="protocol"           type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Protocol. For example, "tcp", "udp".</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="tcpFlags"           type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>TCP flags.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="sourceSap"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Source-SAP (SSAP).</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="destinationSap"    type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Destination-SAP (DSAP).</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="snapType"          type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>SNAP type.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="ipTos"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>IP-TOS.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="ccos"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>C-CoS. Customer or inner Vpri.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="cvid"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>C-VID. Customer or inner VLAN id.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="diffservCodepoint"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Diffserv codepoint.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="ports"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Ports.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="scos"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>S-CoS. Service or outer Vpri.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="svid"             type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>S-VID. Service or outer VLAN id.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-AclAction">
		 <xsd:annotation>
				 <xsd:documentation>
						 ACL action.
						 <br/>
						 Please refer to the "ExtremeXOS Reference" and "ExtremeXOS Concepts Guide" 
						 for a detailed description of the ACL feature and the use of various match conditions
						 and actions.
				 </xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="count"        type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Name of the counter to increment.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="deny"         type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
							<xsd:documentation>
							Indicates whether packet is denied (dropped). If set
							to false, the packet will be permitted (forwarded).
							</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="denyCpu"      type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
							<xsd:documentation>
							Indicates whether packet is not sent to the CPU. 
							</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="copyCpuAndDrop" type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
							<xsd:documentation>
							Indicates whether packet is sent to the CPU.
							</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="qosProfile"   type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>QoS profile to use.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="replaceDot1p" type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether the 802.1p field should be replaced with value from the associated QoS profile.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="replaceDscp"  type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether the DSCP field should be replaced with value from the associated QoS profile.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="sample"       type="xsd:boolean" minOccurs="0" maxOccurs="1">
				</xsd:element>
				<xsd:element name="log"          type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether the packet should be logged.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="logRaw"       type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether the packet should be logged in hex (raw) format.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="mirrorCpu"    type="xsd:boolean" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether a copy of the packet should be mirrored to the CPU.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="redirect"     type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>IP address to forward the packet.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="urpf"         type="xsd:string" minOccurs="0" maxOccurs="1">
				</xsd:element>
				<xsd:element name="meter"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>ACL meter.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="mirror"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Indicates whether a copy of the packet should be sent to the mirror port.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="trafficQueue"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Queue on which to place the traffic.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="redirectPort"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Port to which traffic is redirected.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="link"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Primary port in a trunk port to which traffic is forwarded.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="backUpLink"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Backup port in a trunk port to which traffic forwarded when the primary port is down.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="linkAll"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Forward traffic to all ports in a trunk port when the primary port is down.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="linkNone"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Dont forward traffic when the primary port is down.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="floodGroup"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Flood group that lists ports to which which traffic is forwarded.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="cvid"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>C-VID value to use.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="linkAggregationHash"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Controls which link is used by matching vMAN traffic.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="scos"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>S-CoS value to use.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="stagEthertype"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>S-Tag or vMAN ethertype value to use.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="svid"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>S-VID value to use.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="uplinkport"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>Uplink port to use.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="learningDomain"         type="xsd:string" minOccurs="0" maxOccurs="1">
		 			<xsd:annotation>
						 <xsd:documentation>vMAN to use when learning the source MAC address.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowAction">
		 <xsd:annotation>
				 <xsd:documentation>
						 CLEAR-Flow action.
						 <br/>
						 Please refer to the "ExtremeXOS Reference" and "ExtremeXOS Concepts Guide" 
						 for a detailed description of the CLEAR-Flow feature and the use of various match conditions
						 and actions.
				 </xsd:documentation>
	 	 </xsd:annotation>
         <xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element name="deny"       type="xsd:string">
		 			<xsd:annotation>
						 <xsd:documentation>ACL rule to be changed to deny.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="permit"     type="xsd:string">
		 			<xsd:annotation>
						 <xsd:documentation>ACL rule to be changed to permit.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="qosprofile" type="tns:Policy-ClearflowActionQosProfile">
		 			<xsd:annotation>
						 <xsd:documentation>Change ACL rule with QoS profile.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="mirror"     type="tns:Policy-ClearflowActionAddDeleteAclRule">
		 			<xsd:annotation>
						 <xsd:documentation>Change ACL rule to enable or disable mirroring.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="snmptrap"   type="tns:Policy-ClearflowActionSnmpTrap">
		 			<xsd:annotation>
							<xsd:documentation>SNMP trap that should be sent.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="syslog"     type="tns:Policy-ClearflowActionSyslog">
		 			<xsd:annotation>
							<xsd:documentation>Syslog message that should be sent.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="cli"        type="xsd:string">
		 			<xsd:annotation>
							<xsd:documentation>CLI command.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
         </xsd:choice>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowCondition">
		 <xsd:annotation>
				 <xsd:documentation>
						 CLEAR-Flow condition or comparison expressions.
						 <br/>
						 Please refer to the "ExtremeXOS Reference" and "ExtremeXOS Concepts Guide" 
						 for a detailed description of the CLEAR-Flow feature and the use of various match conditions
						 and actions.
				 </xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="type"       type="tns:Policy-ClearflowConditionType">
		 			<xsd:annotation>
							<xsd:documentation>CLEAR-Flow condition type.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="comparator" type="tns:Policy-ClearflowConditionOperator">
		 			<xsd:annotation>
							<xsd:documentation>CLEAR-Flow condition operator.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="counter1"   type="xsd:string">
		 			<xsd:annotation>
							<xsd:documentation>Counter for the condition.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="counter2"   type="xsd:string">
		 			<xsd:annotation>
							<xsd:documentation>Counter for the condition.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="threshold"  type="xsd:integer">
		 			<xsd:annotation>
							<xsd:documentation>Threshold for the counter.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="hysteresis" type="xsd:integer">
		 			<xsd:annotation>
							<xsd:documentation>Hysteresis for the counter.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="minValue"   type="xsd:integer">
		 			<xsd:annotation>
							<xsd:documentation>Minimum value for the counter.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowActionQosProfile">
		 <xsd:annotation>
			<xsd:documentation>QoS profile for ACL rule.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="aclRule"    type="xsd:string">
		 			<xsd:annotation>
						<xsd:documentation>ACL rule name.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
				<xsd:element name="qosProfile" type="xsd:string">
		 			<xsd:annotation>
						<xsd:documentation>QoS profile.</xsd:documentation>
	 				 </xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowActionAddDeleteAclRule">
		 <xsd:annotation>
			<xsd:documentation>Add or delete mirroring to ACL rule.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="aclRule" type="xsd:string">
		 			<xsd:annotation>
						<xsd:documentation>ACL rule name.</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
				<xsd:element name="add"     type="xsd:boolean">
		 			<xsd:annotation>
						<xsd:documentation>Indicates whether mirror action should be added. If set to false, the mirror action is deleted from the ACL.</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowActionSnmpTrap">
		 <xsd:annotation>
			<xsd:documentation>SNMP trap to be sent.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="id"      type="xsd:integer">
		 			<xsd:annotation>
						<xsd:documentation>Trap OID.</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
				<xsd:element name="message" type="xsd:string">
		 			<xsd:annotation>
						<xsd:documentation>Trap message.</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
				<xsd:element name="period"  type="xsd:integer">
		 			<xsd:annotation>
						<xsd:documentation>Period or interval at which to repeat the trap (in seconds).</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowActionSyslog">
		 <xsd:annotation>
			<xsd:documentation>Syslog message to be sent.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:all>
				<xsd:element name="message" type="xsd:string">
		 			<xsd:annotation>
						<xsd:documentation>Syslog message.</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
				<xsd:element name="level"   type="tns:Policy-ClearflowActionSyslogLevel">
		 			<xsd:annotation>
						<xsd:documentation>Syslog message severity level.</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
				<xsd:element name="period"  type="xsd:integer">
		 			<xsd:annotation>
						<xsd:documentation>Period or interval at which to repeat the message (in seconds).</xsd:documentation>
	 	 			</xsd:annotation>
				</xsd:element>
        </xsd:all>
      </xsd:complexType>

      <xsd:complexType name="Policy-AclRuleSequence">
		 <xsd:annotation>
			<xsd:documentation>Sequence of ACL rules.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:sequence>
          <xsd:element name="rule" type="tns:Policy-AclRule" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="Policy-ClearflowRuleSequence">
		 <xsd:annotation>
			<xsd:documentation>Sequence of CLEAR-Flow rules.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:sequence>
          <xsd:element name="rule" type="tns:Policy-ClearflowRule" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:complexType>

      <!-- Acl types -->

      <xsd:simpleType name="Acl-InsertDirection">
		 <xsd:annotation>
			<xsd:documentation>Enumeration of ACL insert directions.</xsd:documentation>
	 	 </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="BEFORE"/>
          <xsd:enumeration value="AFTER"/>
          <xsd:enumeration value="FIRST"/>
          <xsd:enumeration value="LAST"/>
        </xsd:restriction>
      </xsd:simpleType>

       <xsd:simpleType name="Acl-Direction">
		 <xsd:annotation>
			<xsd:documentation>Enumeration of ACL directions.</xsd:documentation>
	 	 </xsd:annotation>
         <xsd:restriction base="xsd:string">
           <xsd:enumeration value="INGRESS"/>
           <xsd:enumeration value="EGRESS"/>
         </xsd:restriction>
       </xsd:simpleType>
 
    </xsd:schema>
  </types>

  <!-- Vlan messages -->

  <message name="Vlan-createVlanRequest">
		  <part name="name" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="vr"   type="xsd:string">
				<documentation>VR name.</documentation>
		  </part>
  </message>

  <message name="Vlan-createVlanResponse">
  </message>

  <message name="Vlan-deleteVlanRequest">
		  <part name="name" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="vr"   type="xsd:string">
				<documentation>VR name.</documentation>
		  </part>
  </message>

  <message name="Vlan-deleteVlanResponse">
  </message>

  <message name="Vlan-getVlanRequest">
		  <part name="name" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="vr"   type="xsd:string">
				<documentation>VR name.</documentation>
		  </part>
  </message>

  <message name="Vlan-getVlanResponse">
		  <part name="reply" type="tns:Vlan-VlanEntry">
				<documentation>VLAN configuration.</documentation>
		  </part>
  </message>

  <message name="Vlan-getAllVlanRequest">
  </message>

  <message name="Vlan-getAllVlanResponse">
		  <part name="reply" type="tns:Vlan-VlanEntrySequence">
				<documentation>Sequence of VLAN configuration.</documentation>
		  </part>
  </message>

  <!-- Fdb messages -->

  <message name="Fdb-createFdbRequest">
		  <part name="macAddress" type="xsd:string">
				<documentation>MAC address.</documentation>
		  </part>
		  <part name="vlan"       type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port"       type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
  </message>

  <message name="Fdb-createFdbResponse">
  </message>

  <message name="Fdb-deleteFdbRequest">
		  <part name="macAddress" type="xsd:string">
				<documentation>MAC address.</documentation>
		  </part>
		  <part name="vlan"       type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
  </message>

  <message name="Fdb-deleteFdbResponse">
  </message>

  <message name="Fdb-getFdbRequest">
		  <part name="macAddress" type="xsd:string">
				<documentation>MAC address.</documentation>
		  </part>
  </message>

  <message name="Fdb-getFdbResponse">
    <part name="reply" type="tns:Fdb-FdbEntry"/>
  </message>

  <message name="Fdb-getAllFdbRequest">
  </message>

  <message name="Fdb-getAllFdbResponse">
    <part name="reply" type="tns:Fdb-FdbEntrySequence"/>
  </message>

  <!-- Policy messages -->

  <message name="Policy-savePolicyRequest">
		  <part name="name"           type="xsd:string">
				<documentation>Policy name.</documentation>
		  </part>
		  <part name="aclRules"       type="tns:Policy-AclRuleSequence">
				<documentation>ACL rules in the policy.</documentation>
		  </part>
		  <part name="clearflowRules" type="tns:Policy-ClearflowRuleSequence">
				<documentation>CLEAR-Flow rules in the policy.</documentation>
		  </part>
  </message>

  <message name="Policy-savePolicyResponse">
  </message>

  <message name="Policy-deletePolicyRequest">
		  <part name="name" type="xsd:string">
				<documentation>Policy name.</documentation>
		  </part>
  </message>

  <message name="Policy-deletePolicyResponse">
  </message>

  <message name="Policy-getPolicyRequest">
		  <part name="name" type="xsd:string">
				<documentation>Policy name.</documentation>
		  </part>
  </message>

  <message name="Policy-getPolicyResponse">
		  <part name="reply" type="tns:Policy-Policy">
				<documentation>Policy.</documentation>
		  </part>
  </message>

  <message name="Policy-refreshPolicyRequest">
		  <part name="name" type="xsd:string">
				<documentation>Policy name.</documentation>
		  </part>
  </message>

  <message name="Policy-refreshPolicyResponse">
  </message>

  <message name="Policy-listPolicyRequest">
  </message>

  <message name="Policy-listPolicyResponse">
		  <part name="reply" type="tns:Common-StringSequence">
				<documentation>Sequence of policy names.</documentation>
		  </part>
  </message>

  <message name="Policy-bindPolicyOnInterfaceRequest">
		  <part name="name" type="xsd:string">
				<documentation>Policy name.</documentation>
		  </part>
		  <part name="vlan" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port" type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
		  <part name="direction" type="tns:Acl-Direction">
				<documentation>Direction on the interface.</documentation>
		  </part>
  </message>

  <message name="Policy-bindPolicyOnInterfaceResponse">
  </message>

  <message name="Policy-unbindPolicyOnInterfaceRequest">
		  <part name="name" type="xsd:string">
				<documentation>Policy name.</documentation>
		  </part>
		  <part name="vlan" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port" type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
		  <part name="direction" type="tns:Acl-Direction">
					<documentation>Direction on the interface.</documentation>
		  </part>
  </message>

  <message name="Policy-unbindPolicyOnInterfaceResponse">
  </message>

  <message name="Policy-listPolicyOnInterfaceRequest">
		  <part name="vlan" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port" type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
		  <part name="direction" type="tns:Acl-Direction">
				<documentation>Direction on the interface.</documentation>
		  </part>
  </message>

  <message name="Policy-listPolicyOnInterfaceResponse">
    <part name="reply" type="xsd:string"/>
  </message>

  <!-- Acl messages -->

  <message name="Acl-setDynamicAclRequest">
		  <part name="rule" type="tns:Policy-AclRule">
				<documentation>ACL rule.</documentation>
		  </part>
  </message>

  <message name="Acl-setDynamicAclResponse">
  </message>

  <message name="Acl-deleteDynamicAclRequest">
		  <part name="name" type="xsd:string">
				<documentation>ACL name.</documentation>
		  </part>
		  <part name="applicationName" type="xsd:string">
				<documentation>Application name.</documentation>
		  </part>
  </message>

  <message name="Acl-deleteDynamicAclResponse">
  </message>

  <message name="Acl-getDynamicAclRequest">
		  <part name="name" type="xsd:string">
				<documentation>ACL name.</documentation>
		  </part>
  </message>

  <message name="Acl-getDynamicAclResponse">
		  <part name="reply" type="tns:Policy-AclRule">
				<documentation>ACL rule.</documentation>
		  </part>
  </message>

  <message name="Acl-listDynamicAclRequest">
  </message>

  <message name="Acl-listDynamicAclResponse">
		  <part name="reply" type="tns:Common-StringSequence">
				<documentation>Sequence of ACL names.</documentation>
		  </part>
  </message>

  <message name="Acl-insertDynamicAclOnInterfaceRequest">
		  <part name="vlan"         type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port"         type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
		  <part name="newRule"      type="xsd:string">
				<documentation>Name of ACL rule to insert.</documentation>
		  </part>
		  <part name="existingRule" type="xsd:string">
				<documentation>Name of existing ACL rule. Used with direction to specify relative position of the ACL which is to be inserted.</documentation>
		  </part>
		  <part name="direction"    type="tns:Acl-InsertDirection">
				<documentation>ACL insert direction.</documentation>
		  </part>
		  <part name="portDirection"    type="tns:Acl-Direction">
				<documentation>Direction on the interface.</documentation>
		  </part>
		  <part name="priority"     type="xsd:int">
				<documentation>Priority within the zone.</documentation>
		  </part>
		  <part name="zone"         type="xsd:string">
				<documentation>Zone name for the ACL.</documentation>
		  </part>
		  <part name="applicationName"  type="xsd:string">
				<documentation>Application name within the zone.</documentation>
		  </part>
  </message>

  <message name="Acl-insertDynamicAclOnInterfaceResponse">
  </message>

  <message name="Acl-removeDynamicAclOnInterfaceRequest">
		  <part name="vlan" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port" type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
		  <part name="rule" type="xsd:string">
				<documentation>ACL name.</documentation>
		  </part>
		  <part name="portDirection"    type="tns:Acl-Direction">
				<documentation>Direction on the interface.</documentation>
		  </part>
		  <part name="applicationName" type="xsd:string">
				<documentation>Application name.</documentation>
		  </part>
  </message>

  <message name="Acl-removeDynamicAclOnInterfaceResponse">
  </message>

  <message name="Acl-removeDynamicAclOnAllInterfacesRequest">
		  <part name="rule" type="xsd:string">
				<documentation>ACL name.</documentation>
		  </part>
		  <part name="applicationName" type="xsd:string">
				<documentation>Application name.</documentation>
		  </part>
  </message>

  <message name="Acl-removeDynamicAclOnAllInterfacesResponse">
  </message>

  <message name="Acl-listDynamicAclOnInterfaceRequest">
		  <part name="vlan" type="xsd:string">
				<documentation>VLAN name.</documentation>
		  </part>
		  <part name="port" type="xsd:string">
				<documentation>Port number.</documentation>
		  </part>
		  <part name="direction" type="tns:Acl-Direction">
				<documentation>Direction on the interface.</documentation>
		  </part>
  </message>

  <message name="Acl-listDynamicAclOnInterfaceResponse">
		  <part name="reply" type="tns:Common-StringSequence">
				<documentation>Sequence of ACL names.</documentation>
		  </part>
  </message>

  <!-- Cfgmgr messages -->

  <message name="Cfgmgr-execConfigRequest">
    <part name="config" type="xsd:string"/>
  </message>

  <message name="Cfgmgr-execConfigResponse">
  </message>

  <message name="Cfgmgr-execCliRequest">
		  <part name="command" type="xsd:string">
				<documentation>CLI command to execute.</documentation>
		  </part>
  </message>

  <message name="Cfgmgr-execCliResponse">
		  <part name="reply" type="xsd:string">
				<documentation>Output of the CLI command.</documentation>
		  </part>
  </message>

  <!-- Port for XOS XML APIs. -->

  <portType name="XosPortType">

    <!-- Vlan operations -->

    <operation name="createVlan">
		<documentation>
		(Deprecated) Create new VLAN.
		 <br/>
		 NOTE: All VLAN-related operations and types defined here are deprecated.
		 Use switch.wsdl and vlan.xsd instead.
		</documentation>
      <input  message="tns:Vlan-createVlanRequest"/>
      <output message="tns:Vlan-createVlanResponse"/>
    </operation>

    <operation name="deleteVlan">
		<documentation>
		(Deprecated) Delete VLAN.
		 <br/>
		 NOTE: All VLAN-related operations and types defined here are deprecated.
		 Use switch.wsdl and vlan.xsd instead.
		</documentation>
      <input  message="tns:Vlan-deleteVlanRequest"/>
      <output message="tns:Vlan-deleteVlanResponse"/>
    </operation>

    <operation name="getVlan">
		<documentation>
		(Deprecated) Get a VLAN.
		 <br/>
		 NOTE: All VLAN-related operations and types defined here are deprecated.
		 Use switch.wsdl and vlan.xsd instead.
		</documentation>
      <input  message="tns:Vlan-getVlanRequest"/>
      <output message="tns:Vlan-getVlanResponse"/>
    </operation>

    <operation name="getAllVlan">
		<documentation>
		(Deprecated) Get all VLANs.
		 <br/>
		 NOTE: All VLAN-related operations and types defined here are deprecated.
		 Use switch.wsdl and vlan.xsd instead.
		</documentation>
      <input  message="tns:Vlan-getAllVlanRequest"/>
      <output message="tns:Vlan-getAllVlanResponse"/>
    </operation>

    <!-- Fdb operations -->

    <operation name="createFdb">
		<documentation>
		Create FDB entry.
		</documentation>
      <input  message="tns:Fdb-createFdbRequest"/>
      <output message="tns:Fdb-createFdbResponse"/>
    </operation>

    <operation name="deleteFdb">
		<documentation>
		Delete the FDB entry for a MAC address.
		</documentation>
      <input  message="tns:Fdb-deleteFdbRequest"/>
      <output message="tns:Fdb-deleteFdbResponse"/>
    </operation>

    <operation name="getFdb">
		<documentation>
		Get the FDB entry for a MAC address.
		</documentation>
      <input  message="tns:Fdb-getFdbRequest"/>
      <output message="tns:Fdb-getFdbResponse"/>
    </operation>

    <operation name="getAllFdb">
		<documentation>
		Get all FDB entries.
		</documentation>
      <input  message="tns:Fdb-getAllFdbRequest"/>
      <output message="tns:Fdb-getAllFdbResponse"/>
    </operation>

    <!-- Policy operations -->

    <operation name="savePolicy">
      <documentation>
		Create new policy.
      </documentation>
      <input  message="tns:Policy-savePolicyRequest"/>
      <output message="tns:Policy-savePolicyResponse"/>
    </operation>

    <operation name="deletePolicy">
      <documentation>
		Delete policy.
      </documentation>
      <input  message="tns:Policy-deletePolicyRequest"/>
      <output message="tns:Policy-deletePolicyResponse"/>
    </operation>

    <operation name="getPolicy">
      <documentation>
		Get  policy.
      </documentation>
      <input  message="tns:Policy-getPolicyRequest"/>
      <output message="tns:Policy-getPolicyResponse"/>
    </operation>

    <operation name="refreshPolicy">
      <documentation>
		Refresh policy on all the interfaces that it is applied to.
      </documentation>
       <input  message="tns:Policy-refreshPolicyRequest"/>
      <output message="tns:Policy-refreshPolicyResponse"/>
    </operation>

    <operation name="listPolicy">
      <documentation>
		Get names of all policies.
      </documentation>
      <input  message="tns:Policy-listPolicyRequest"/>
      <output message="tns:Policy-listPolicyResponse"/>
    </operation>

    <operation name="bindPolicyOnInterface">
      <documentation>
Bind policy to an interface.
An interface could be a VLAN, a port or the special ANY interface.
If neither VLAN nor port is specified, it refers to the ANY interface.
      </documentation>
      <input  message="tns:Policy-bindPolicyOnInterfaceRequest"/>
      <output message="tns:Policy-bindPolicyOnInterfaceResponse"/>
    </operation>

    <operation name="unbindPolicyOnInterface">
      <documentation>
Unbind policy from an interface.
If policy name is specified, it will remove the policy from all interfaces that it is applied.
If policy name is NOT specified, then it will remove any policy that is currently applied on the interface specified.
An interface could be a VLAN, a port or the special ANY interface.
If neither VLAN nor port is specified, it refers to the ANY interface.
      </documentation>
      <input  message="tns:Policy-unbindPolicyOnInterfaceRequest"/>
      <output message="tns:Policy-unbindPolicyOnInterfaceResponse"/>
    </operation>

    <operation name="listPolicyOnInterface">
      <documentation>
Lists the name of the policy applied on the specified interface.
An interface could be a VLAN, a port or the special ANY interface.
If neither VLAN nor port is specified, it refers to the ANY interface.
      </documentation>
      <input  message="tns:Policy-listPolicyOnInterfaceRequest"/>
      <output message="tns:Policy-listPolicyOnInterfaceResponse"/>
    </operation>

    <!-- Acl operations -->

    <operation name="setDynamicAcl">
      <documentation>
		Create dynamic ACL.
      </documentation>
      <input  message="tns:Acl-setDynamicAclRequest"/>
      <output message="tns:Acl-setDynamicAclResponse"/>
    </operation>

    <operation name="deleteDynamicAcl">
      <documentation>
		Delete dynamic ACL.
      </documentation>
      <input  message="tns:Acl-deleteDynamicAclRequest"/>
      <output message="tns:Acl-deleteDynamicAclResponse"/>
    </operation>

    <operation name="getDynamicAcl">
      <documentation>
		Get dynamic ACL.
      </documentation>
      <input  message="tns:Acl-getDynamicAclRequest"/>
      <output message="tns:Acl-getDynamicAclResponse"/>
    </operation>

    <operation name="listDynamicAcl">
      <documentation>
		Get names of all dynamic ACLs.
      </documentation>
      <input  message="tns:Acl-listDynamicAclRequest"/>
      <output message="tns:Acl-listDynamicAclResponse"/>
    </operation>

    <operation name="insertDynamicAclOnInterface">
      <documentation>
	  Insert dynamic ACL on interface. 
		If no existing dynamic ACL rule is specified, the new dynamic ACL will be inserted either as the first or the last ACL rule.
An interface could be a VLAN, a port or the special ANY interface.
If neither VLAN nor port is specified, it refers to the ANY interface.
      </documentation>
      <input  message="tns:Acl-insertDynamicAclOnInterfaceRequest"/>
      <output message="tns:Acl-insertDynamicAclOnInterfaceResponse"/>
    </operation>

    <operation name="removeDynamicAclOnInterface">
      <documentation>
Remove dynamic ACL from interface.
An interface could be a VLAN, a port or the special ANY interface.
If neither VLAN nor port is specified, it refers to the ANY interface.
      </documentation>
      <input  message="tns:Acl-removeDynamicAclOnInterfaceRequest"/>
      <output message="tns:Acl-removeDynamicAclOnInterfaceResponse"/>
    </operation>

    <operation name="removeDynamicAclOnAllInterfaces">
      <documentation>
Remove dynamic ACL from all interfaces.
      </documentation>
      <input  message="tns:Acl-removeDynamicAclOnAllInterfacesRequest"/>
      <output message="tns:Acl-removeDynamicAclOnAllInterfacesResponse"/>
    </operation>

    <operation name="listDynamicAclOnInterface">
      <documentation>
		Get names of all the dynamic ACLs on an interface.
An interface could be a VLAN, a port or the special ANY interface.
If neither VLAN nor port is specified, it refers to the ANY interface.
      </documentation>
      <input  message="tns:Acl-listDynamicAclOnInterfaceRequest"/>
      <output message="tns:Acl-listDynamicAclOnInterfaceResponse"/>
    </operation>

    <!-- Fdb operations -->

    <operation name="execConfig">
      <documentation>
Execute EXOS native XML configuration.
      </documentation>
      <input  message="tns:Cfgmgr-execConfigRequest"/>
      <output message="tns:Cfgmgr-execConfigResponse"/>
    </operation>

    <operation name="execCli">
      <documentation>
			  Execute  CLI command. This will execute the CLI command and return the output.
			  The returned output is the same as that seen when executing the command from a CLI
			  session.
      </documentation>
      <input  message="tns:Cfgmgr-execCliRequest"/>
      <output message="tns:Cfgmgr-execCliResponse"/>
    </operation>
  </portType>

  <!-- Binding for XOS XML APIs. -->

  <binding name="XosBinding" type="tns:XosPortType">
    <soap:binding style="rpc"
                  transport="http://schemas.xmlsoap.org/soap/http"/>

    <!-- Vlan operation bindings -->

    <operation name="createVlan">
      <soap:operation soapAction="urn:xapi/l2protocol/vlan"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="deleteVlan">
      <soap:operation soapAction="urn:xapi/l2protocol/vlan"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="getVlan">
      <soap:operation soapAction="urn:xapi/l2protocol/vlan"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="getAllVlan">
      <soap:operation soapAction="urn:xapi/l2protocol/vlan"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/vlan"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <!-- Fdb operation bindings -->

    <operation name="createFdb">
      <soap:operation soapAction="urn:xapi/l2protocol/fdb"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="deleteFdb">
      <soap:operation soapAction="urn:xapi/l2protocol/fdb"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="getFdb">
      <soap:operation soapAction="urn:xapi/l2protocol/fdb"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="getAllFdb">
      <soap:operation soapAction="urn:xapi/l2protocol/fdb"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/fdb"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <!-- Policy operation bindings -->

    <operation name="savePolicy">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="deletePolicy">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="getPolicy">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="refreshPolicy">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="listPolicy">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="bindPolicyOnInterface">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="unbindPolicyOnInterface">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="listPolicyOnInterface">
      <soap:operation soapAction="urn:xapi/system/policy"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/system/policy"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <!-- Acl operation bindings -->

    <operation name="setDynamicAcl">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="deleteDynamicAcl">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="getDynamicAcl">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="listDynamicAcl">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="insertDynamicAclOnInterface">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="removeDynamicAclOnInterface">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="removeDynamicAclOnAllInterfaces">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="listDynamicAclOnInterface">
      <soap:operation soapAction="urn:xapi/l2protocol/acl"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/l2protocol/acl"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <!-- Acl operation bindings -->

    <operation name="execConfig">
      <soap:operation soapAction="urn:xapi/cfgmgmt/cfgmgr"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/cfgmgmt/cfgmgr"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/cfgmgmt/cfgmgr"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

    <operation name="execCli">
      <soap:operation soapAction="urn:xapi/cfgmgmt/cfgmgr"/>
      <input>
        <soap:body use="literal"
                   namespace="urn:xapi/cfgmgmt/cfgmgr"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </input>
      <output>
        <soap:body use="literal"
                   namespace="urn:xapi/cfgmgmt/cfgmgr"
                   encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>
      </output>
    </operation>

  </binding>

  <!-- Endpoint for XOS XML APIs. -->
  <service name="Xos">
    <port name="XosPort" binding="tns:XosBinding">
      <soap:address location="http://localhost/xapi"/>
    </port>
  </service>

</definitions>
